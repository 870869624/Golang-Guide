> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/jiushao-ing/p/17643095.html)

在 jmeter 线程组的第一篇文章中对 Ramp-Up 时间讲过一点：

[jmeter 详解 - 线程组详解（1）-Thread Group](https://www.cnblogs.com/jiushao-ing/p/17629879.html) 
=========================================================================================

这里我们再来看一下 Ramp-Up(seconds)

在 jmeter 中 Ramp-Up 是什么？

JMeter Ramp-up 周期是以秒为单位，Apache Meter 将花费多少时间将所有测试用户 (线程) 添加到测试执行中。或者换句话说，需要多长时间开始执行所有的线程

例子：

*   1000 个目标线程，Ramp-up 时间为 1000 秒: JMeter 将每秒添加一个用户
*   1000 个目标线程，Ramp-up 时间为 100 秒: JMeter 将每秒添加 10 个用户
*   1000 个目标线程，Ramp-up 时间为 50 秒: JMeter 将每秒添加 20 个用户

性能测试关键之一是模拟应用程序实际负载的能力。但是确定目标负载的并发用户数是不够的。在与测试阶段使用的目标负载相同的情况下，测试的应用程序可能会在生产环境中失败。

应用程序可能在测试负载下失败，如果某个问题确实为系统中的瓶颈。之所以发生这样的事，除了目标负载之外，开发人员和性能测试人员还应该关心在测试执行期间负载是如何随着时间分布的，而 Ramp-up 有助于我们为应用程序模拟各种负载场景。

来看一个例子：

1）首先，我们创建一个具有目标线程数的线程组 (假设为 100 个)。

鼠标右击测试计划 --> 添加 --> 线程组 --> 线程组

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819211459919-544454518.png)

2）然后添加访问测试 Web 应用程序主页的 http 请求

3）然后我们添加一个监听器：Active Threads Over Time

添加 --> 监听器 --> _jp@gc - Active Threads Over Time_

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819212055507-350381589.png)

注意：如果有大量的目标线程，Ramp-up 不应该是 0。Ramp-up 为 0 意味着 JMeter 测试脚本将在测试执行开始时同时添加所有线程，因此它将立即对应用程序造成非常严重的负载。

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819213225978-446976441.png)

当然，有的时候我们希望模拟这样的负载，例如在尖峰性能测试，但是这是一个单独的案例，但即使是 尖峰性能测试，我们通常也不希望所有用户都在测试执行的第一秒钟内到达。

这个场景并不现实，通常这样的负载分布没有任何意义。如果你有一个网络应用程序，用户通常会或多或少地逐渐来到你的网站，你的服务器有足够的时间进行适当的调整和扩展。

Ramp-up 时间到底多大取决于我们的需要，所以，需要做的第一件事就是确定测试目标。在许多情况下，我们可以从生产环境中找出合适的负载模式。然后我们可以创造一个线性坡道，这表明用户逐渐进网站或页面

4）回到基础线程组 Thread Group，我们将 Ramp-up 时间设置为 120

持续时间 5 分钟，Ramp-up 时间 2 分钟，所以持续负载的停留时间为 3 分钟。这里的意义是，在坡道结束后，所有用户都启动并运行，有足够的等待时间。等待时间确认系统能够处理负载，性能保持稳定且不会恶化。

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819214344924-800043672.png)

5）执行测试，我们可以看到 2 分钟内活跃用户的数量是如何逐渐增长的。 

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819215311503-339001331.png)

这种负载的方式叫做 “线性”。这种方法适用于大多数关心目标负载的用户。然而，这种做法并不是最佳做法。如果服务器在线性爬升过程中在特定负载线程数下表现不佳，通常很难隔离和确定是哪个负载线程数。我们不清楚服务器可以处理哪些数量的负载，不能处理哪些数量的负载。

这就是为什么按步骤执行负载要好得多的原因。让我们把测试持续时间分成几个阶段：

**使用阶梯式负载**

这次我们仍然测试 100 个用户，但我们将逐步地将他们提升。我们将从 25 个用户开始在一定时间内保持一个负载，查看服务器如何处理它。之后我们会再加 25 个到 50 个再加 25 个到 75 个，最后加 25 个到 100 个用户。这种方法效果好得多，也更可靠。

这里我们使用插件：Ultimate Thread Group

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819215509854-1508231661.png)

Ultimate Thread Group 线程组下的内容与基础线程组 Thread Group 一样，可以复制一份过来

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819215917637-411932879.png)

 Ultimate Thread Group 提供了一个 Threads Sch edule'表，您可以在其中配置不同的线程组。

您可以决定线程的数量 (“开始线程计数”)、每个组开始添加到测试执行之前的延迟(“初始延迟，秒”)、组的上升时间(“启动时间，秒”)、在下坡之前保持组的时间(“保持加载时间，秒”) 以及关闭指定组的所有线程的速度(“关闭时间）

所有线程组同时启动，但每个线程组都有自己的 “初始延迟” 值，这有助于单独启动每个组的用户。

Ultimate Thread Group 插件的另一个特性是，您可以在下面的图表中看到预期的负载分布，并根据您的需要调整分布值，甚至在运行脚本之前也不需要考虑复杂的计算。

让我们把测试分成 4 个步骤，每分钟增加 25 个用户。在这种情况下，我们的线程调度将看起来像这样。

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819221006907-736200179.png)

**尖峰测试** 

这种负载灵活性可能有用的另一个很好的例子是尖峰测试。基本上，尖峰测试是一种性能测试，在这种情况下，应用程序在负载意外增加和减少的情况下进行测试，看看它在这种情况下的表现，以及它是否能够处理这样的尖峰。

如下图，我们可以配置出一个尖峰出来：

![](https://img2023.cnblogs.com/blog/2565457/202308/2565457-20230819221308008-1311587634.png)