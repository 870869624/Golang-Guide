根据你提供的信息，我来帮你分析在离线环境下如何打包镜像并替换服务。从你的Makefile来看，有几个关键点：

## 分析Makefile可用部分

在离线环境下，以下部分是可用的：

```makefile
buildi:
	@echo "Start building docker image......"
# 在非sw64架构下，直接使用vendor目录（你已经拷贝了gomodvendor）
ifneq ($(ARCH),sw64)
	@go mod tidy
	@go mod vendor
endif
	@docker build \
		--build-arg BUILDER_IMAGE=$(builderImage) \
		--build-arg BASIC_IMAGE=$(basicImage) \
		--build-arg BUILD_CGO=$(CGO_ENABLED) \
		--build-arg BUILD_ARCH=$(ARCH) \
		--build-arg LDFLAGS=$(ldFlags) \
		-t $(targetImage):$(VERSION) -f ./docker/Dockerfile ./
	@docker tag $(targetImage):$(VERSION) $(targetImage):latest
	@rm -rf ./vendor/
	@rm -rf ./go-porter/
	@echo "End building docker image succeed......"
```

## 离线环境操作步骤

### 1. 准备环境变量

首先需要设置构建所需的变量：

```bash
export ARCH=amd64  # 根据实际架构调整
export VERSION=v1.0.0  # 设置版本号
export targetImage=cleansvc  # 目标镜像名称
# 其他可能需要的变量...
```

### 2. 修改构建脚本（针对离线环境）

由于是离线环境，需要调整：

```makefile
buildi-offline:
	@echo "Start building docker image in offline mode......"
	# 跳过go mod相关命令，直接使用vendor
	@docker build \
		--build-arg BUILDER_IMAGE=$(builderImage) \
		--build-arg BASIC_IMAGE=$(basicImage) \
		--build-arg BUILD_CGO=$(CGO_ENABLED) \
		--build-arg BUILD_ARCH=$(ARCH) \
		--build-arg LDFLAGS=$(ldFlags) \
		-t $(targetImage):$(VERSION) -f ./docker/Dockerfile ./
	@docker tag $(targetImage):$(VERSION) $(targetImage):latest
	@echo "End building docker image succeed......"
```

### 3. 实际操作流程

#### 步骤1：修改代码

```bash
# 在拷贝的项目目录中修改代码
cd /your/project/path
# 进行代码修改...
```

#### 步骤2：打包镜像

```bash
# 执行构建（使用修改后的Makefile目标）
make buildi-offline

# 或者使用原Makefile但设置适当的环境变量
export PUSH=false
make buildi
```

#### 步骤3：导入镜像到K8s环境

由于是离线环境，需要将镜像导入到目标机器的Docker中：

**方法1：保存为tar文件**

```bash
# 在构建机器上
docker save -o cleansvc-new.tar docker-hub.cloud.top/aiop/cleansvc-arm64:latest

tar cvzf ag-arm.tar.gz ag-arm.tar （打包）

tar -zvxf ag-arm.tar.gz （解压）

# 拷贝到目标机器并加载
docker load -i cleansvc-new.tar

k3s ctr images import clean_engine.tar

```

**方法2：如果使用私有仓库**

```bash
# 推送到内网私有仓库（如果存在）
docker tag cleansvc:latest internal-registry/cleansvc:latest
docker push internal-registry/cleansvc:latest
```

#### 步骤4：替换K8s服务

**方法A：滚动重启Deployment**

```bash
kubectl rollout restart deployment cleansvc -n sdsp
```

**方法B：直接修改镜像版本**

```bash
kubectl set image deployment/cleansvc cleansvc=cleansvc:latest -n sdsp
```

**方法C：通过yaml文件更新**

```bash
# 如果有原始的部署文件
kubectl apply -f cleansvc-deployment.yaml -n sdsp
```

### 4. 验证部署

```bash
# 查看Pod状态
kubectl get pods -n sdsp -l app=cleansvc

# 查看滚动更新状态
kubectl rollout status deployment/cleansvc -n sdsp

# 查看日志确认新版本正常运行
kubectl logs -f deployment/cleansvc -n sdsp
```

### 5. 完整操作示例

```bash
# 1. 修改代码后构建镜像
make buildi

# 2. 保存镜像
docker save -o cleansvc-new.tar cleansvc:latest

# 3. 在目标机器加载镜像
docker load -i cleansvc-new.tar

# 4. 重启服务
kubectl rollout restart deployment cleansvc -n sdsp

# 5. 等待并验证
kubectl rollout status deployment/cleansvc -n sdsp
kubectl get pods -n sdsp | grep cleansvc
```

## 注意事项

1. **确认架构**：确保构建架构与目标环境一致
2. **镜像存储**：离线环境下要确保镜像能正确传输到K8s节点
3. **依赖检查**：确认Dockerfile中的基础镜像在离线环境可用
4. **备份原镜像**：建议先备份原镜像以便回滚

按照这个流程，你应该能在离线环境下成功打包并更新cleansvc服务。

kubectl get pod cleansvc-59978d465c-mssxk -n sdsp -o wide

# 保存当前运行的镜像
docker save -o cleansvc-backup-$(date +%Y%m%d-%H%M%S).tar <image-name>:<tag>

# 例如：
docker save -o cleansvc-backup.tar docker-hub.cloud.top/aiop/cleansvc-arm64:latest